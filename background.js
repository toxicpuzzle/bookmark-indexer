// Background service worker for bookmark processing
console.log('Bookmark Organizer: Background service worker started');

// Listen for extension installation
chrome.runtime.onInstalled.addListener(async (details) => {
  if (details.reason === 'install') {
    console.log('Extension installed, initializing...');
    await initializeExtension();
  } else if (details.reason === 'update') {
    console.log('Extension updated');
  }
});

// Initialize extension
async function initializeExtension() {
  try {
    // Set default settings
    await chrome.storage.sync.set({
      settings: {
        autoGenerateDescriptions: true,
        apiProvider: 'none', // 'openai', 'anthropic', 'none'
        apiKey: '',
        enableSemanticSearch: true,
        lastSyncDate: null
      }
    });

    console.log('Extension initialized successfully');
  } catch (error) {
    console.error('Error initializing extension:', error);
  }
}

// Listen for bookmark changes
chrome.bookmarks.onCreated.addListener((id, bookmark) => {
  console.log('New bookmark created:', bookmark);
  processNewBookmark(id, bookmark);
});

chrome.bookmarks.onRemoved.addListener((id, removeInfo) => {
  console.log('Bookmark removed:', id);
  removeBookmarkData(id);
});

chrome.bookmarks.onChanged.addListener((id, changeInfo) => {
  console.log('Bookmark changed:', id, changeInfo);
  updateBookmarkData(id, changeInfo);
});

// Process new bookmark
async function processNewBookmark(id, bookmark) {
  if (!bookmark.url) return; // Skip folders

  try {
    const settings = await getSettings();
    const enhancedData = {
      id: id,
      url: bookmark.url,
      title: bookmark.title,
      dateAdded: bookmark.dateAdded,
      description: '',
      tags: [],
      category: '',
      embedding: null,
      lastProcessed: Date.now()
    };

    // Store the enhanced bookmark data
    const key = `bookmark_${id}`;
    await chrome.storage.local.set({ [key]: enhancedData });

    // Optionally generate description
    if (settings.autoGenerateDescriptions && settings.apiKey) {
      generateDescription(id, bookmark);
    }
  } catch (error) {
    console.error('Error processing new bookmark:', error);
  }
}

// Remove bookmark data
async function removeBookmarkData(id) {
  try {
    const key = `bookmark_${id}`;
    await chrome.storage.local.remove(key);
  } catch (error) {
    console.error('Error removing bookmark data:', error);
  }
}

// Update bookmark data
async function updateBookmarkData(id, changeInfo) {
  try {
    const key = `bookmark_${id}`;
    const result = await chrome.storage.local.get(key);
    if (result[key]) {
      const data = result[key];
      if (changeInfo.title) data.title = changeInfo.title;
      if (changeInfo.url) data.url = changeInfo.url;
      data.lastProcessed = Date.now();
      await chrome.storage.local.set({ [key]: data });
    }
  } catch (error) {
    console.error('Error updating bookmark data:', error);
  }
}

// Generate description using AI
async function generateDescription(id, bookmark) {
  try {
    const settings = await getSettings();
    if (!settings.apiKey || settings.apiProvider === 'none') return;

    // Fetch page content
    const response = await fetch(bookmark.url);
    const html = await response.text();

    // Extract text content (simple approach)
    const text = html.replace(/<[^>]*>/g, ' ').substring(0, 2000);

    let description = '';

    if (settings.apiProvider === 'openai') {
      description = await generateWithOpenAI(settings.apiKey, bookmark.title, text);
    } else if (settings.apiProvider === 'anthropic') {
      description = await generateWithAnthropic(settings.apiKey, bookmark.title, text);
    }

    // Update bookmark data with description
    const key = `bookmark_${id}`;
    const result = await chrome.storage.local.get(key);
    if (result[key]) {
      result[key].description = description;
      await chrome.storage.local.set({ [key]: result[key] });
    }
  } catch (error) {
    console.error('Error generating description:', error);
  }
}

async function generateWithOpenAI(apiKey, title, content) {
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [{
          role: 'user',
          content: `Generate a concise 1-2 sentence description for this bookmarked webpage. Title: "${title}". Content preview: ${content}`
        }],
        max_tokens: 100
      })
    });

    const data = await response.json();
    return data.choices[0].message.content.trim();
  } catch (error) {
    console.error('OpenAI API error:', error);
    return '';
  }
}

async function generateWithAnthropic(apiKey, title, content) {
  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307',
        max_tokens: 100,
        messages: [{
          role: 'user',
          content: `Generate a concise 1-2 sentence description for this bookmarked webpage. Title: "${title}". Content preview: ${content}`
        }]
      })
    });

    const data = await response.json();
    return data.content[0].text.trim();
  } catch (error) {
    console.error('Anthropic API error:', error);
    return '';
  }
}

// Helper to get settings
async function getSettings() {
  const result = await chrome.storage.sync.get('settings');
  return result.settings || {};
}

// Message handler for popup/options communication
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'getAllBookmarks') {
    getAllBookmarks().then(sendResponse);
    return true; // Async response
  } else if (request.action === 'syncBookmarks') {
    syncAllBookmarks().then(sendResponse);
    return true;
  } else if (request.action === 'searchBookmarks') {
    searchBookmarks(request.query).then(sendResponse);
    return true;
  }
});

// Get all bookmarks with enhanced data
async function getAllBookmarks() {
  try {
    const bookmarkTree = await chrome.bookmarks.getTree();
    const allBookmarks = [];

    function traverse(nodes) {
      for (const node of nodes) {
        if (node.url) {
          allBookmarks.push(node);
        }
        if (node.children) {
          traverse(node.children);
        }
      }
    }

    traverse(bookmarkTree);

    // Get enhanced data for each bookmark
    const enhancedBookmarks = await Promise.all(
      allBookmarks.map(async (bookmark) => {
        const key = `bookmark_${bookmark.id}`;
        const result = await chrome.storage.local.get(key);
        return {
          ...bookmark,
          enhanced: result[key] || null
        };
      })
    );

    return enhancedBookmarks;
  } catch (error) {
    console.error('Error getting all bookmarks:', error);
    return [];
  }
}

// Sync all existing bookmarks
async function syncAllBookmarks() {
  try {
    const bookmarkTree = await chrome.bookmarks.getTree();
    let count = 0;

    async function traverse(nodes) {
      for (const node of nodes) {
        if (node.url) {
          await processNewBookmark(node.id, node);
          count++;
        }
        if (node.children) {
          await traverse(node.children);
        }
      }
    }

    await traverse(bookmarkTree);

    // Update last sync date
    const settings = await getSettings();
    settings.lastSyncDate = Date.now();
    await chrome.storage.sync.set({ settings });

    return { success: true, count };
  } catch (error) {
    console.error('Error syncing bookmarks:', error);
    return { success: false, error: error.message };
  }
}

// Search bookmarks
async function searchBookmarks(query) {
  try {
    const allBookmarks = await getAllBookmarks();
    const lowerQuery = query.toLowerCase();

    // Simple text search for now
    const results = allBookmarks.filter(bookmark => {
      const titleMatch = bookmark.title.toLowerCase().includes(lowerQuery);
      const urlMatch = bookmark.url.toLowerCase().includes(lowerQuery);
      const descMatch = bookmark.enhanced?.description?.toLowerCase().includes(lowerQuery);

      return titleMatch || urlMatch || descMatch;
    });

    return results;
  } catch (error) {
    console.error('Error searching bookmarks:', error);
    return [];
  }
}
