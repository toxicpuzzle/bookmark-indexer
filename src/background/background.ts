// Background service worker for bookmark processing
import type {
  Bookmark,
  BookmarkWithEnhanced,
  EnhancedBookmarkData,
  ExtensionSettings,
  Message,
  MessageResponse,
  SyncResult,
  OpenAIRequest,
  OpenAIResponse,
  AnthropicRequest,
  AnthropicResponse,
} from '../types';

console.log('Bookmark Organizer: Background service worker started');

// Listen for extension installation
chrome.runtime.onInstalled.addListener(async (details) => {
  if (details.reason === 'install') {
    console.log('Extension installed, initializing...');
    await initializeExtension();
  } else if (details.reason === 'update') {
    console.log('Extension updated');
  }
});

// Initialize extension
async function initializeExtension(): Promise<void> {
  try {
    // Set default settings
    const defaultSettings: ExtensionSettings = {
      autoGenerateDescriptions: true,
      apiProvider: 'none',
      apiKey: '',
      enableSemanticSearch: true,
      lastSyncDate: null,
    };

    await chrome.storage.sync.set({ settings: defaultSettings });
    console.log('Extension initialized successfully');
  } catch (error) {
    console.error('Error initializing extension:', error);
  }
}

// Listen for bookmark changes
chrome.bookmarks.onCreated.addListener((id: string, bookmark: chrome.bookmarks.BookmarkTreeNode) => {
  console.log('New bookmark created:', bookmark);
  processNewBookmark(id, bookmark);
});

chrome.bookmarks.onRemoved.addListener((id: string, removeInfo: chrome.bookmarks.BookmarkRemoveInfo) => {
  console.log('Bookmark removed:', id);
  removeBookmarkData(id);
});

chrome.bookmarks.onChanged.addListener((id: string, changeInfo: chrome.bookmarks.BookmarkChangeInfo) => {
  console.log('Bookmark changed:', id, changeInfo);
  updateBookmarkData(id, changeInfo);
});

// Process new bookmark
async function processNewBookmark(id: string, bookmark: chrome.bookmarks.BookmarkTreeNode): Promise<void> {
  if (!bookmark.url) return; // Skip folders

  try {
    const settings = await getSettings();
    const enhancedData: EnhancedBookmarkData = {
      id: id,
      url: bookmark.url,
      title: bookmark.title,
      dateAdded: bookmark.dateAdded || Date.now(),
      description: '',
      tags: [],
      category: '',
      embedding: null,
      lastProcessed: Date.now(),
    };

    // Store the enhanced bookmark data
    const key = `bookmark_${id}`;
    await chrome.storage.local.set({ [key]: enhancedData });

    // Optionally generate description
    if (settings.autoGenerateDescriptions && settings.apiKey) {
      generateDescription(id, bookmark);
    }
  } catch (error) {
    console.error('Error processing new bookmark:', error);
  }
}

// Remove bookmark data
async function removeBookmarkData(id: string): Promise<void> {
  try {
    const key = `bookmark_${id}`;
    await chrome.storage.local.remove(key);
  } catch (error) {
    console.error('Error removing bookmark data:', error);
  }
}

// Update bookmark data
async function updateBookmarkData(id: string, changeInfo: chrome.bookmarks.BookmarkChangeInfo): Promise<void> {
  try {
    const key = `bookmark_${id}`;
    const result = await chrome.storage.local.get(key);
    if (result[key]) {
      const data = result[key] as EnhancedBookmarkData;
      if (changeInfo.title) data.title = changeInfo.title;
      if (changeInfo.url) data.url = changeInfo.url;
      data.lastProcessed = Date.now();
      await chrome.storage.local.set({ [key]: data });
    }
  } catch (error) {
    console.error('Error updating bookmark data:', error);
  }
}

// Generate description using AI
async function generateDescription(id: string, bookmark: chrome.bookmarks.BookmarkTreeNode): Promise<void> {
  if (!bookmark.url) return;

  try {
    const settings = await getSettings();
    if (!settings.apiKey || settings.apiProvider === 'none') return;

    // Fetch page content
    const response = await fetch(bookmark.url);
    const html = await response.text();

    // Extract text content (simple approach)
    const text = html.replace(/<[^>]*>/g, ' ').substring(0, 2000);

    let description = '';

    if (settings.apiProvider === 'openai') {
      description = await generateWithOpenAI(settings.apiKey, bookmark.title, text);
    } else if (settings.apiProvider === 'anthropic') {
      description = await generateWithAnthropic(settings.apiKey, bookmark.title, text);
    }

    // Update bookmark data with description
    const key = `bookmark_${id}`;
    const result = await chrome.storage.local.get(key);
    if (result[key]) {
      const data = result[key] as EnhancedBookmarkData;
      data.description = description;
      await chrome.storage.local.set({ [key]: data });
    }
  } catch (error) {
    console.error('Error generating description:', error);
  }
}

async function generateWithOpenAI(apiKey: string, title: string, content: string): Promise<string> {
  try {
    const requestBody: OpenAIRequest = {
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'user',
          content: `Generate a concise 1-2 sentence description for this bookmarked webpage. Title: "${title}". Content preview: ${content}`,
        },
      ],
      max_tokens: 100,
    };

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify(requestBody),
    });

    const data: OpenAIResponse = await response.json();
    return data.choices[0].message.content.trim();
  } catch (error) {
    console.error('OpenAI API error:', error);
    return '';
  }
}

async function generateWithAnthropic(apiKey: string, title: string, content: string): Promise<string> {
  try {
    const requestBody: AnthropicRequest = {
      model: 'claude-3-haiku-20240307',
      max_tokens: 100,
      messages: [
        {
          role: 'user',
          content: `Generate a concise 1-2 sentence description for this bookmarked webpage. Title: "${title}". Content preview: ${content}`,
        },
      ],
    };

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify(requestBody),
    });

    const data: AnthropicResponse = await response.json();
    return data.content[0].text.trim();
  } catch (error) {
    console.error('Anthropic API error:', error);
    return '';
  }
}

// Helper to get settings
async function getSettings(): Promise<ExtensionSettings> {
  const result = await chrome.storage.sync.get('settings');
  return result.settings || {
    autoGenerateDescriptions: true,
    apiProvider: 'none',
    apiKey: '',
    enableSemanticSearch: true,
    lastSyncDate: null,
  };
}

// Message handler for popup/options communication
chrome.runtime.onMessage.addListener(
  (
    request: Message,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: MessageResponse) => void
  ) => {
    if (request.action === 'getAllBookmarks') {
      getAllBookmarks().then(sendResponse);
      return true; // Async response
    } else if (request.action === 'syncBookmarks') {
      syncAllBookmarks().then(sendResponse);
      return true;
    } else if (request.action === 'searchBookmarks') {
      searchBookmarks(request.query || '').then(sendResponse);
      return true;
    }
  }
);

// Get all bookmarks with enhanced data
async function getAllBookmarks(): Promise<BookmarkWithEnhanced[]> {
  try {
    const bookmarkTree = await chrome.bookmarks.getTree();
    const allBookmarks: chrome.bookmarks.BookmarkTreeNode[] = [];

    function traverse(nodes: chrome.bookmarks.BookmarkTreeNode[]): void {
      for (const node of nodes) {
        if (node.url) {
          allBookmarks.push(node);
        }
        if (node.children) {
          traverse(node.children);
        }
      }
    }

    traverse(bookmarkTree);

    // Get enhanced data for each bookmark
    const enhancedBookmarks = await Promise.all(
      allBookmarks.map(async (bookmark) => {
        const key = `bookmark_${bookmark.id}`;
        const result = await chrome.storage.local.get(key);
        return {
          ...bookmark,
          enhanced: (result[key] as EnhancedBookmarkData) || null,
        } as BookmarkWithEnhanced;
      })
    );

    return enhancedBookmarks;
  } catch (error) {
    console.error('Error getting all bookmarks:', error);
    return [];
  }
}

// Sync all existing bookmarks
async function syncAllBookmarks(): Promise<SyncResult> {
  try {
    const bookmarkTree = await chrome.bookmarks.getTree();
    let count = 0;

    async function traverse(nodes: chrome.bookmarks.BookmarkTreeNode[]): Promise<void> {
      for (const node of nodes) {
        if (node.url) {
          await processNewBookmark(node.id, node);
          count++;
        }
        if (node.children) {
          await traverse(node.children);
        }
      }
    }

    await traverse(bookmarkTree);

    // Update last sync date
    const settings = await getSettings();
    settings.lastSyncDate = Date.now();
    await chrome.storage.sync.set({ settings });

    return { success: true, count };
  } catch (error) {
    console.error('Error syncing bookmarks:', error);
    return { success: false, error: (error as Error).message };
  }
}

// Search bookmarks
async function searchBookmarks(query: string): Promise<BookmarkWithEnhanced[]> {
  try {
    const allBookmarks = await getAllBookmarks();
    const lowerQuery = query.toLowerCase();

    // Simple text search for now
    const results = allBookmarks.filter((bookmark) => {
      const titleMatch = bookmark.title.toLowerCase().includes(lowerQuery);
      const urlMatch = bookmark.url ? bookmark.url.toLowerCase().includes(lowerQuery) : false;
      const descMatch = bookmark.enhanced?.description?.toLowerCase().includes(lowerQuery);

      return titleMatch || urlMatch || descMatch;
    });

    return results;
  } catch (error) {
    console.error('Error searching bookmarks:', error);
    return [];
  }
}
